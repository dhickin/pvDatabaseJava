<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>pvDatabaseJava</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="http://epics-pvdata.sourceforge.net/script/tocgen.js">
 </script>
</head>

<body>

<div class="head">
<h1>pvDatabaseJava</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date. -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 04-Feb-2015</h2>
<dl>
    <dt>Latest version:</dt>
    <dd><a
       href="pvDatabaseJava.html">pvDatabaseJava.html</a>
    </dd>
    <dt>This version:</dt>
    <dd><a
       href= "pvDatabaseJava20150204.html">pvDatabaseJava20150204.html
    </a> </dd>
    <dt>Previous version:</dt>
    <dd><a
       href= "pvDatabaseJava20150130.html">pvDatabaseJava20150130.html
    </a> </dd>
  <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL</dd>
</dl>

  <p class="copyright">This product is made available subject to acceptance of the <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">EPICS open source license.</a></p>
<hr />

<h2 class="nocount">Abstract</h2>

<p>This document describes pvDatabaseJava,
which is a framework for implementing a network accessible database of smart memory resident
records. Network access is via pvAccess. The data in each record is a top level PVStructure as defined by
pvData. The framework includes a complete implementation of ChannelProvider as defined by pvAccess.
The framework can be extended in order to create record instances that implements services.
The minimum that an extension must provide is a top level PVStructure and a process method.
</p>

<p>EPICS version 4 is a set of related products in the EPICS
V4 control system programming environment:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumentsV4.html">relatedDocumentsV4.html</a>
</p>


<h2 class="nocount">Status of this Document</h2>

<p>This is the 04-Feb-2015 version of of pvDatabaseJava.</p>
<p>
This version is a complete implementation of what is described in this manual.
</p>
<p>Since the last version:</p>
<dl>
  <dt>SimpleExample</dt>
    <dd>This is a new example that creates three different types of records,
      creates the database and starts pvAccess all in one source file.
    </dd>
   <dt>addListener</dt>
     <dd>Before ChannelProviderLocalFactory had to
      call PVRecordField::addListener with strange rules about locking.
      Now the implementation in PVRecord does this.
     </dd>
</dl>
<p>The following will be done next:</p>
<dl>
  <dt>Update pvDatabaseCPP</dt>
    <dd>pvDatabaseJava is based on pvDatabaseCPP.
     Development resulted in a better implementation of some components.
     Similar changes should be made in pvDatabaseCPP.
    </dd>
   <dt>pvDatabaseJava.html</dt>
     <dd>More work on this document.</dd>
   <dt>Regression Tests</dt>
      <dd>pvDatabase, both Java and CPP, have examples but
       no regression tests.
      </dd>
</dl>
</div>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>Introduction</h2>
<p>The main purpose of this project to make it easier to implement services that are accessed via pvAccess.
This project supplies a complete implementation of the server side of pvAccess.
All that a service has to provide is a top level PVStructure and a process method.
</p>

<p>A brief description of a pvDatabase is that it is a set of network accessible, smart,
memory resident records.
Each record has data composed of a top level PVStructure.
Each record has a name which is the channelName for pvAccess.
A local Channel Provider implements the complete ChannelProvider and
Channel interfaces as defined by pvAccess.
The local provider provides access to the records in the pvDatabase.
This local provider is accessed by the remote pvAccess server.
A record is smart because code can be attached to a record, which is accessed via a method named process.</p>

<p>This document describes components that provide the following features:</p>
<dl>
  <dt>pvdatabase</dt>
     <dd>This encapsulates the concept of a database of memory resident smart records.
        The two main components are:
       <dl>
          <dt>PVRecord</dt>
             <dd>This encapsulates the concept of a smart record. It can be processed.
             Changes to field values can be trapped. A record can be locked.</dd>
          <dt>PVDatabase</dt>
              <dd>This is a database of pvRecords.
               Records can be added and removed from a database.</dd>
       </dl>
     </dd>
  <dt>pva</dt>
     <dd>This is a complete implementation of ChannelProvider and Channel
       as defined by pvAccess.
       It provides pvAccess for PVRecords.
       </dd>
</dl>
<p>PVRecord is a base class that makes it easy to create record instances.
Given a PVStructure, the PVRecord constructor can be called to create a new PVRecord
instance.
If the structure has a timeStamp field then the base class process routine
sets the timeStamp to the current time.
Otherwise process does nothing.
</p>
<p>
Server code can extend the base class.
It should provide a static create method that creates the top level
PVStructure and creates a new PVRecord
that extends PVRecord.
It can  override the following methods:</p>
<dl>
  <dt>Constructor</dt>
    <dd>A derived class constructor must call the base class constructor.</dd>
  <dt>process</dt>
    <dd>This is what makes a record smart.
      The base class just looks for a timeStamp field and if it exists
      it is set equal to the current time.
     A derived class can do what it wants.
     </dd>
  <dt>destroy</dt>
     <dd>This releases any resources used by the implementation.
     </dd>
</dl>
<p>JavaDoc is available at <a
href="./html/index.html">javaDoc</a></p>
<h2>Getting started</h2>
<h3>SimpleExample</h3>
<p>This is an example that creates PVRecords, adds them to the database,
and starts pvAccess all in a single source file.</p>
<p>Three examples of extending PVRecord are shown:</p>
<dl>
   <dt>PassiveScalarRecord</dt>
     <dd>This overides neither process or destroy.
      The only difference from directly calling the base class constructor
      is that a static create method is provided.
      </dd>
   <dt>ScanPVRecord</dt>
      <dd>This is an example that periodically makes the record process.
       Since process is not overriden only the timeStamp will update
       unless a client changes it.
      </dd>
   <dt>CounterRecord</dt>
      <dd>This increments value each time the record is processed.</dd>
</dl>
<p>The main program creates a record of each type, adds each record to the
database, and starts the pvAccess server.
</p>
<pre>
public class SimpleExample {

    static class PassiveScalarRecord extends PVRecord
    {
        static PassiveScalarRecord create(
                String recordName,
                ScalarType scalarType,
                String properties)
        {
            return new PassiveScalarRecord(
                    recordName,
                    StandardPVFieldFactory.getStandardPVField().scalar(
                            scalarType, properties)
                    );
        }

        private PassiveScalarRecord(
                String recordName,
                PVStructure pvStructure)
        {
            super(recordName, pvStructure);
        }
    }

    static class ScanPVRecord extends PVRecord implements TimerCallback 
    {
        private static Timer timer = TimerFactory.create(
                "ScanPVRecord-timer",
                ThreadPriority.middle);
        private final TimerNode timerNode = TimerFactory.createNode(this);

        ScanPVRecord(
                String recordName,
                PVStructure pvStructure,double period)
                {
            super(recordName, pvStructure);
            timer.schedulePeriodic(timerNode, 0, period);
                }

        public void destroy() {
            timerNode.cancel();
            super.destroy();
        }

        public void callback() {
            lock();
            try {
                beginGroupPut();
                process();
                endGroupPut();
            } finally {
                unlock();
            }
        }

        public void timerStopped() {
            // noop
        }
    }

    // 1Hz 32-bit counter
    static class CounterRecord extends ScanPVRecord
    {
        static CounterRecord create(String recordName)
        {
            return new CounterRecord(
                    recordName,
                    StandardPVFieldFactory.getStandardPVField().scalar(
                            ScalarType.pvInt,
                            "timeStamp"));
        }

        private final PVInt value;

        private CounterRecord(String recordName, PVStructure pvStructure) {
            super(recordName, pvStructure, 1.0);
            value = pvStructure.getIntField("value");
        }

        public void process() {
            // increment value
            value.put(value.get() + 1);
            // update timeStamp
            super.process();
        }
    }

    public static void main(String[] args)
    {
        PVDatabase master = PVDatabaseFactory.getMaster();
        master.addRecord(PassiveScalarRecord.create(
                "testScalar",
                ScalarType.pvInt,
                "timeStamp"));
        master.addRecord(new ScanPVRecord(
                "testScan",
                StandardPVFieldFactory.getStandardPVField().scalar(
                        ScalarType.pvString,
                        "timeStamp"),
                        1.0));
        master.addRecord(CounterRecord.create("testCounter"));

        ContextLocal context = new ContextLocal();
        context.start(true);
    }
}
</pre>
<h3>Hello World</h3>
<p>pvDatabaseJava provides a pom.xml files so that maven can be used to
build it.
</p>
<p>One of the examples is HelloExample.
It can be run via the shell script provided with this project.
</p>
<pre>
mrk&gt; pwd
/home/hg/pvDatabaseJava/shell
source source
java org.epics.pvdatabase.pva.example.HelloExample \
    -recordName helloExample \
    -traceLevel 1
</pre>
<p>You should see something like the following:</p>
<pre>
pvAccess Server v4.1.0-SNAPSHOT
CLASS   : org.epics.pvaccess.server.impl.remote.ServerContextImpl
VERSION : pvAccess Server v4.1.0-SNAPSHOT
CHANNEL PROVIDER : local
BEACON_ADDR_LIST : 
AUTO_BEACON_ADDR_LIST : true
BEACON_PERIOD : 15.0
BROADCAST_PORT : 5076
SERVER_PORT : 5075
RCV_BUFFER_SIZE : 16384
IGNORE_ADDR_LIST: 
STATE : INITIALIZED

Running server...
</pre>
<p>Then in another window execute a pvput and pvget as follows:</p>
<pre>
mrk&gt; pvput -r "argument.value" helloExample
...
mrk&gt; pvget -r "result.value" helloExample
helloExample
structure 
    structure result
        string value Hello World
mrk&gt; 
</pre>

<h2>Guidelines For Developing PVRecords</h2>
<h3>Client Driven Records</h3>
<p>This means that process is called by clients not by the service itself.</p>
<p>The PVRecord base class can be used to create records
that can driven entirely by client except for setting a value
for the timeStamp.
The ExampleDatabase shows how to construct such records.
</p>
<p>The following is an example record meant to be accessed via channelPutGet.
</p>
<pre>
public class HelloRecord extends PVRecord {
    private static final FieldCreate fieldCreate
        = FieldFactory.getFieldCreate();
    private static final PVDataCreate pvDataCreate
        = PVDataFactory.getPVDataCreate();
    private static final StandardField standardField
        = StandardFieldFactory.getStandardField();
    
    private PVString arg;
    private PVString result;

    public static PVRecord create(String recordName)
    {
        FieldBuilder fb = fieldCreate.createFieldBuilder();
        Structure structure = 
            fb.addNestedStructure("argument").
                add("value",ScalarType.pvString).
                endNested().
            addNestedStructure("result").
                add("value",ScalarType.pvString).
                endNested().
            add("timeStamp",standardField.timeStamp()).
            createStructure();
       PVRecord pvRecord = new HelloRecord(
            recordName,pvDataCreate.createPVStructure(structure));
       PVDatabase master = PVDatabaseFactory.getMaster();
       master.addRecord(pvRecord);
       return pvRecord;
    }
    public HelloRecord(String recordName,PVStructure pvStructure) {
        super(recordName,pvStructure);
        arg = pvStructure.getSubField(PVString.class, "argument.value");
        if(arg==null) throw new IllegalArgumentException("arg not found");
        result = pvStructure.getSubField(PVString.class, "result.value");
        if(result==null) throw
            new IllegalArgumentException("result not found");
        
    }
    
    public void process()
    {
        int level = getTraceLevel();
        if(levels&gt;1) System.out.println("HelloRecord::process");
        result.put("Hello " +arg.get());
        super.process();
    }
}
</pre>
<h3>Service Driven Records</h3>
<p>This means that the service calls process because it is the data source.</p>
<p>The following is an example.</p>
<pre>
public class ArrayServerRecord extends PVRecord implements Runnable {
    private static final StandardPVField standardPVFields
         = StandardPVFieldFactory.getStandardPVField();
    private PVDoubleArray pvValue = null;
    private double[] value;
    private Thread thread;
    private int arraySize;
    private long waitTime;
    private double elementValue = 0.0;

    public static PVRecord create(
         String recordName,
         int arraySize,
         double waitSecs)
    {
        PVStructure pvStructure = standardPVField.scalarArray(i
            ScalarType.pvDouble, "alarm,timeStamp");
        PVRecord pvRecord = new ArrayServerRecord(
            recordName,pvStructure,arraySize,waitSecs);
        PVDatabase master = PVDatabaseFactory.getMaster();
        master.addRecord(pvRecord);
        return pvRecord;
    }
    public ArrayServerRecord(
        String recordName,
        PVStructure pvStructure,
        int arraySize,
        double waitSecs)
    {

        super(recordName,pvStructure);
        this.arraySize = arraySize;
        waitTime = (long)(waitSecs*1000.0);
        pvValue = pvStructure.getSubField(PVDoubleArray.class, "value");
        if(pvValue==null) throw new IllegalArgumentException("value not found");
        value = new double[arraySize];
        thread = new Thread(this,"ArrayServerReord");
        thread.start();
    }

    public void process()
    {
        pvValue.put(0, value.length, value, 0);
        super.process();
    }

    public void run() {
        while(true) {
            try {
                Thread.sleep(waitTime);
            } catch (Throwable th) {
                th.printStackTrace();
            }
            value = new double[arraySize];
            for(int i=0; i&lt;arraySize; i++) value[i] = elementValue + i;
            ++elementValue;
            lock();
            try {
                beginGroupPut();
                process();
                endGroupPut();
            } finally {
                unlock();
            }
        }
    }
}
</pre>
<h2>org.epics.pvdatabase</h2>
<p>This Package has the following files:</p>
<dl>
   <dt>PVDatabase</dt>
     <dd>
      Interface for a pvdatabase.
     </dd>
   <dt>PVRecord</dt>
     <dd>
       The base class for PVRecord.
     </dd>
   <dt>PVDatabaseFactory</dt>
     <dd>A factory for a pvdatabase.</dd>
   <dt>PVListener</dt>
     <dd>Interface for code that listens for changes to fields.</dd>
   <dt>PVRecordClient</dt>
     <dd>Interface for code that accesses a PVRecord</dd>
   <dt>PVRecordField</dt>
     <dd>Interface that connects a PVField to a PVRecord</dd>
   <dt>PVRecordStructure</dt>
     <dd>Interface that connects a PVStructure to a PVRecord</dd>
</dl>

<h2>org.epics.pvdatabase.pva</h2>
<p>This is code that provides an implementation of channelProvider as
defined by pvAccess.
It provides access to PVRecords and is accessed by the server side of remote pvAccess.
It uses the copy and monitor facilities from pvDataJava and connects
them to a PVRecord.
</p>
<p>The implementation is a complete implementation of channelProvider
and channel except for channelRPC, which is implement by pvAccess as a separate
channel provider.</p>
<p>
It is not of interest to client or service implementers.
See the JavaDoc
<a href="./html/index.html">javaDoc</a>
for details.
</p>
<h2>org.epics.pvdatabase.example</h2>
<p>This package has three example service records.</p>
<dl>
  <dt>HelloRecord</dt>
    <dd>
       This is an example of a record that is best accessed via
      a channelPutGet. Process generates
      a result that is "Hello " + argument.value.
    </dd>
  <dt>AplusBRecord</dt>
    <dd>
      This has three PVDouble fields, named a, v, and c.
      Process sets c = a + b.
    </dd>
  <dt>ArrayServerRecord</dt>
    <dd>
     This is an example of a service that is a data source.
     It has a thread that periodically changes the data 
     for an array of doubles.
     It than processes the record which puts
     the new array data into the value field.
    </dd>
</dl>
<h2>org.epics.pvdatabase.pva.example</h2>
<dl>
  <dt>SimpleExample</dt>
    <dd>This was discussed above.</dd>
  <dt>ExampleDatabase</dt>
    <dd>
     This is creates four PVRecords.
<pre>
An AplusB record.
An ArrayServerRecord
A standardPVField with a value that is a PVDouble.
A standardPVField with a value that is a PVDoubleArray.
</pre>
    </dd>
  <dt>HelloExample</dt>
    <dd>
      This creates a single HelloRecord.
    </dd>
</dl>
<h2>org.epics.pvdatabase.perform</h2>
<dl>
  <dt>DoubleArrayPut</dt>
    <dd>
     This is a client that connects to a standardPVField with a value
     that is a PVDoubleArray.
     It then it repeatedly does puts with different array
     sizes and value.
     It periodically destroys the connection and then reconnects.
    </dd>
  <dt>DoublePut</dt>
    <dd>
     This is a client that connects to a standardPVField with a value
     that is a PVDouble.
     It then it repeatedly does puts with different values.
     It periodically destroys the connection and then reconnects.
    </dd>
  <dt>MonitorCount</dt>
    <dd>
     This is a client that monitors an arbitrary PVRecord.
     It periodically destroys the connection and then reconnects.
    </dd>
</dl>
<h2>shell</h2>
<p>This is a set of files that show how to use the command line
to start the example databases and the perform clients.
These have only been tested on linux.</p>
<p>To use them go to this directory, or better copy the entire directory
to another location and then:</p>
<ul>
   <li>edit source so the WORKSPACE references where You have pvDataJava,
pvAccessJava, easyPVAJava, and pvDatabaseJava.</li>
   <li>Execute:
<pre>
source source
</pre>
    </li>
    <li>Look at the example of what you want to do,
      Each shows the default args for each command.
    </li>
    <li>Run the command with the arguments You want.</li>
</ul>

<dl>
  <dt>source</dt>
    <dd>
      definitions for defining the environment variable CLASSPATH.
    </dd>
  <dt>exampleHello</dt>
    <dd>
      Starts the HelloExample database,
    </dd>
  <dt>exampleDatabase</dt>
    <dd>
      Starts the ExampleDatabase.
       To start the other examples replace ExampeDatabase 
       by AplusBRecord, HelloExample or SimpleExample.
    </dd>
  <dt>doublePut</dt>
    <dd>
     Runs the DoublePut client.
    </dd>
  <dt>doubleArrayPut</dt>
    <dd>
     Runs the DoubleArrayPut client.
    </dd>
  <dt>monitorCount</dt>
    <dd>
     Runs the MonitorCount client.
    </dd>
</dl>
</div>
</body>
</html>
